# API для фронтенда — 3D-модели

Краткое описание, как бэкенд работает и как с ним интегрироваться.

---

## Общая схема

1. **Загрузка** — фронт шлёт OBJ-файл → бэкенд сохраняет в MinIO и возвращает метаданные.
2. **Список** — запрос списка файлов → бэкенд отдаёт ключи и типы (для отображения и выбора модели).
3. **Просмотр** — по `s3ObjectKey` запрашивается glTF → бэкенд конвертирует OBJ → glTF на лету и отдаёт JSON (данные мешей в base64 внутри JSON).
4. **Удаление** — по `s3ObjectKey` файл удаляется из хранилища.

Базовый путь API: **`/files`** (относительно хоста бэкенда).

---

## Эндпоинты

| Метод | Путь | Назначение |
|-------|------|------------|
| `POST` | `/files/upload` | Загрузить OBJ |
| `GET`  | `/files` | Список всех файлов |
| `GET`  | `/files/{objectKey}` | Инфо по одному файлу |
| `GET`  | `/files/{objectKey}/gltf` | Получить модель в формате glTF (для вьюера) |
| `DELETE` | `/files/{objectKey}` | Удалить файл |

**Важно:** `{objectKey}` — это идентификатор файла в хранилище (например `model.obj` или `folder/model.obj`). Его нужно **кодировать в URL**: `encodeURIComponent(objectKey)` (пробелы и спецсимволы в имени файла).

---

## 1. Загрузка OBJ

- **URL:** `POST /files/upload`
- **Content-Type:** `multipart/form-data`
- **Тело:** одно поле `file` — сам OBJ-файл (до 2 ГБ).

**Ответ 200:** JSON вида:

```json
{
  "fileType": "obj",
  "s3ObjectKey": "my-model.obj"
}
```

Дальше для просмотра и удаления используется `s3ObjectKey`.

---

## 2. Список файлов

- **URL:** `GET /files`
- **Ответ 200:** массив объектов:

```json
[
  { "fileType": "obj", "s3ObjectKey": "model1.obj" },
  { "fileType": "obj", "s3ObjectKey": "model2.obj" }
]
```

По `s3ObjectKey` можно строить ссылки на просмотр и на glTF.

---

## 3. Инфо по файлу

- **URL:** `GET /files/{objectKey}`
- **Ответ 200:** тот же формат, что и один элемент списка:

```json
{
  "fileType": "obj",
  "s3ObjectKey": "my-model.obj"
}
```

---

## 4. Получить glTF для вьюера

- **URL:** `GET /files/{objectKey}/gltf`
- **Важно:** подставлять в путь уже закодированный ключ:  
  `GET /files/${encodeURIComponent(objectKey)}/gltf`

**Ответ 200:**

- **Content-Type:** `application/json`
- **Тело:** один JSON в формате glTF 2.0:
  - сцена, ноды, меши, accessors, bufferViews;
  - геометрия (вершины, нормали, индексы) лежит в **одном буфере** в поле `buffers[0].uri` в виде **base64** (`data:application/octet-stream;base64,...`).

Типичный размер ответа для тяжёлых моделей — десятки мегабайт (из-за base64). Таймаут на запрос лучше ставить большим (например 5 минут).

**Ошибки:**

- Файл не OBJ → 500 с текстом вроде `Only OBJ files are supported for glTF conversion`.
- Файл не найден или ошибка конвертации → 500 с сообщением об ошибке.

**На фронте:**

- Делать `fetch(url)` → `response.json()` — получится glTF-объект.
- Буфер брать из `gltf.buffers[0].uri`: отрезать префикс `data:application/octet-stream;base64,` и декодировать base64 в `ArrayBuffer` (или использовать парсер/Three.js GLTFLoader с поддержкой embedded buffer).
- Имеет смысл кэшировать полученный glTF по `objectKey`, чтобы не качать одну и ту же модель повторно.

---

## 5. Удаление файла

- **URL:** `DELETE /files/{objectKey}`
- **Ответ:** 204 No Content при успехе.

---

## Рекомендации для фронта

1. **Базовый URL** — брать из конфига (например `VITE_API_URL` или `NEXT_PUBLIC_API_URL`), не хардкодить.
2. **Кодирование ключа** — везде, где в путь подставляется `objectKey`, использовать `encodeURIComponent(objectKey)`.
3. **glTF** — один запрос на модель, ответ — самодостаточный glTF с embedded buffer (base64). Кэш по `s3ObjectKey` уменьшит повторные загрузки.
4. **Таймаут** для `GET .../gltf` — ставить не меньше 1–2 минут для больших моделей (на бэкенде конвертация может быть долгой).
5. **CORS** — на ответ glTF бэкенд добавляет `Access-Control-Allow-Origin: *`; при необходимости то же можно настроить для остальных эндпоинтов.

Если нужны примеры запросов (curl/fetch) или описание в OpenAPI — можно добавить отдельным разделом.
