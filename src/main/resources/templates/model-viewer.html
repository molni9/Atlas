<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        canvas {
            width: 100%;
            height: 100%;
        }
        #modelList {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            color: #333;
            border-radius: 12px;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            border: 1px solid #ddd;
        }
        #modelList h3 {
            color: #333;
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }
        .model-item {
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: all 0.2s;
            margin: 5px 0;
            border-radius: 6px;
        }
        .model-item:hover {
            background: #f5f5f5;
            transform: translateX(5px);
        }
        .model-item.active {
            background: #e3f2fd;
            color: #1976d2;
            font-weight: bold;
            border-left: 4px solid #1976d2;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 30px;
            border-radius: 8px;
            display: none;
            font-size: 18px;
        }
        #noModels {
            color: #666;
            text-align: center;
            padding: 20px;
            font-style: italic;
        }
        #errorMessage {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 8px;
            display: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <div id="modelList">
        <h3>Available 3D Models</h3>
        <div id="noModels">Loading models...</div>
    </div>
    <div id="loading">Loading model...</div>
    <div id="errorMessage"></div>

    <!-- Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xf0f0f0);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        camera.position.z = 5;

        // Model loaders
        const gltfLoader = new THREE.GLTFLoader();
        const objLoader = new THREE.OBJLoader();
        const mtlLoader = new THREE.MTLLoader();

        let currentModel = null;
        let currentModelName = null;

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        // Load models from MinIO
        async function loadModelsFromMinIO() {
            try {
                const response = await fetch('/files');
                if (!response.ok) {
                    throw new Error('Failed to fetch models list');
                }
                const models = await response.json();
                const modelList = document.getElementById('modelList');
                const noModelsDiv = document.getElementById('noModels');
                
                if (models.length === 0) {
                    noModelsDiv.textContent = 'No 3D models found';
                    return;
                }

                noModelsDiv.style.display = 'none';
                modelList.innerHTML = '<h3>Available 3D Models</h3>';
                
                models.forEach(model => {
                    if (!model.fileAttributesId) {
                        console.error('Model missing ID:', model);
                        return;
                    }
                    const div = document.createElement('div');
                    div.className = 'model-item';
                    div.textContent = model.fileName || 'Unnamed Model';
                    div.setAttribute('data-model-id', model.fileAttributesId);
                    div.onclick = () => {
                        console.log('Loading model with ID:', model.fileAttributesId);
                        loadModelFromMinIO(model.fileAttributesId);
                    };
                    modelList.appendChild(div);
                });

                // Load first model if available
                if (models.length > 0 && models[0].fileAttributesId) {
                    console.log('Loading first model with ID:', models[0].fileAttributesId);
                    loadModelFromMinIO(models[0].fileAttributesId);
                }
            } catch (error) {
                console.error('Error loading model list:', error);
                showError('Error loading models list: ' + error.message);
                document.getElementById('noModels').textContent = 'Error loading models';
            }
        }

        // Load model from MinIO
        async function loadModelFromMinIO(modelId) {
            console.log('Attempting to load model with ID:', modelId);
            if (!modelId) {
                console.error('Invalid model ID received:', modelId);
                showError('Invalid model ID');
                return;
            }

            try {
                document.getElementById('loading').style.display = 'block';
                
                // First get the model info to check the file type
                const modelInfoResponse = await fetch(`/files/${modelId}`);
                if (!modelInfoResponse.ok) {
                    throw new Error('Failed to fetch model info');
                }
                const modelInfo = await modelInfoResponse.json();
                console.log('Model info:', modelInfo);
                
                // Then get the model content
                const response = await fetch(`/files/${modelId}/content`);
                if (!response.ok) {
                    throw new Error('Failed to fetch model');
                }
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                
                const contentType = response.headers.get('content-type');
                console.log('Content-Type:', contentType);
                console.log('File extension:', modelInfo.fileName?.split('.').pop()?.toLowerCase());
                
                let model;
                if (contentType?.includes('gltf') || 
                    contentType?.includes('glb') ||
                    modelInfo.fileName?.toLowerCase().endsWith('.gltf') ||
                    modelInfo.fileName?.toLowerCase().endsWith('.glb')) {
                    console.log('Loading as GLTF/GLB model');
                    model = await loadGLTF(url);
                } else if (contentType?.includes('obj') || 
                          contentType?.includes('octet-stream') ||
                          modelInfo.fileName?.toLowerCase().endsWith('.obj')) {
                    console.log('Loading as OBJ model');
                    model = await loadOBJ(url);
                } else {
                    console.error('Unsupported content type or file extension:', {
                        contentType,
                        fileName: modelInfo.fileName
                    });
                    throw new Error('Unsupported file format');
                }
                
                if (currentModel) {
                    scene.remove(currentModel);
                }
                
                currentModel = model;
                scene.add(currentModel);
                
                // Center and scale the model
                const box = new THREE.Box3().setFromObject(currentModel);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 2.0 / maxDim;
                currentModel.scale.setScalar(scale);
                
                currentModel.position.sub(center.multiplyScalar(scale));
                
                URL.revokeObjectURL(url);

                // Update active model in list
                if (currentModelName) {
                    const prevActive = document.querySelector(`.model-item[data-model-id="${currentModelName}"]`);
                    if (prevActive) prevActive.classList.remove('active');
                }
                currentModelName = modelId;
                const newActive = document.querySelector(`.model-item[data-model-id="${modelId}"]`);
                if (newActive) newActive.classList.add('active');

                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('Error loading model:', error);
                showError('Error loading model: ' + error.message);
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Model loading functions
        function loadGLTF(url) {
            return new Promise((resolve, reject) => {
                gltfLoader.load(
                    url,
                    (gltf) => resolve(gltf.scene),
                    undefined,
                    (error) => reject(error)
                );
            });
        }

        function loadOBJ(url) {
            return new Promise((resolve, reject) => {
                // First try to load the MTL file if it exists
                const mtlUrl = url.replace('.obj', '.mtl');
                fetch(mtlUrl)
                    .then(response => {
                        if (response.ok) {
                            return response.blob().then(blob => URL.createObjectURL(blob));
                        }
                        return null;
                    })
                    .then(mtlUrl => {
                        if (mtlUrl) {
                            mtlLoader.load(mtlUrl, materials => {
                                materials.preload();
                                objLoader.setMaterials(materials);
                                loadOBJModel(url, resolve, reject);
                            }, undefined, reject);
                        } else {
                            loadOBJModel(url, resolve, reject);
                        }
                    })
                    .catch(error => {
                        console.log('No MTL file found, loading OBJ without materials');
                        loadOBJModel(url, resolve, reject);
                    });
            });
        }

        function loadOBJModel(url, resolve, reject) {
            objLoader.load(
                url,
                (object) => {
                    // Center the model
                    const box = new THREE.Box3().setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    object.position.sub(center);
                    
                    // Add basic material if no materials were loaded
                    if (object.children.length > 0 && !object.children[0].material) {
                        object.traverse(child => {
                            if (child instanceof THREE.Mesh) {
                                child.material = new THREE.MeshPhongMaterial({
                                    color: 0x808080,
                                    specular: 0x050505,
                                    shininess: 30
                                });
                            }
                        });
                    }
                    
                    resolve(object);
                },
                undefined,
                (error) => reject(error)
            );
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Load initial model list
        loadModelsFromMinIO();
    </script>
</body>
</html> 